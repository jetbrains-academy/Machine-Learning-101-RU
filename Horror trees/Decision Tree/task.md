Реализуйте рекурсивный алгоритм построения дерева решения в виде класса `DecisionTree`.

Структура класса приведена ниже:

    class DecisionTree:
        def build(self, X, y, score=entropy):
            # рекурсивный алгоритм построения дерева
            return self

Метод build должен:
- Оценить информативность всех возможных предикатов для всех признаков с помощью функции score.
  Для построения всех возможных предикатов для конкретного признака нужно определить уникальные значения данного признака.
  Следующий шаг – сконструировать пороговые условия для признака относительно полученных уникальных значений.
  Обратите внимание, что признаки в датасете двух типов – номинальные и количественные.
  Для номинальных признаков количество предикатов будет равно количеству уникальных значений признака и
  пороговое условие превратится в проверку признака на равенство.
- Выбрать наилучшее с точки зрения информативности разбиение.
- Для наилучшего разбиения рекурсивно построить правое и левое поддеревья.
