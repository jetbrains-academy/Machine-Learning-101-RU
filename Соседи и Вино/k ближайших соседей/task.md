Метод ближайших соседей (k-nearest neighbours) исходит из предположения, что схожие объекты расположены вблизи друг друга. Иными словами, что классифицируемый объект относится к тому классу, которому принадлежат ближайшие к нему объекты обучающей выборки.

Близость объектов, или же их сходство, определяется некоторой метрикой - отсюда и название алгоритма [метрический классификатор](http://www.machinelearning.ru/wiki/index.php?title=%D0%9C%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80). 

К примеру, сорта **зинфандель** и **примитиво** происходят от общего предка и по многим метрикам были бы классифицированы как вина одного класса. Это приводит к тому, что производители нередко указывают на упаковке данные сорта как взаимозаменяемые.

<div class="hint">Предположение из первого абзаца про схожие объекты называется <a href = "http://www.machinelearning.ru/wiki/index.php?title=%D0%93%D0%B8%D0%BF%D0%BE%D1%82%D0%B5%D0%B7%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8">гипотеза компактности</a>. Она гласит, что схожие объекты гораздо чаще лежат в одном классе, чем в разных.</div>
<div class="hint">
$$
\rho(u,x_1)\leq\rho(u,x_2)\leq...\leq\rho(u,x_l)$$
$x_i$ - i-й сосед объекта u

$y_i$ - класс i-го соседа u
$$
a(u, X^l) = \arg \max\limits_{y\in Y} \sum\limits_{y_i=y} w(i,u)
$$
$w(i,u) = [i\leq k]$
</div>

\
Классификатор k-nearest neighbors не предполагает отдельной процедуры обучения, классификация
каждого объекта состоит из следующих шагов:

- Рассчитать расстояния от классифицируемого объекта до каждого объекта в выборке
- Отсортировать объекты на основании расстояния до классифицируемого объекта (от наименьшего расстояния к наибольшему)
- Выбрать первые K объектов из отсортированного списка
- Вернуть наиболее часто встречающуюся метку среди этих K объектов. Здесь метка - это идентификатор класса.


В данном задании заранее приведены две функции для вычисления расстояния между объектами - [евклидово](https://ru.wikipedia.org/wiki/%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%BE%D0%B2%D0%B0_%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0) (euclidean_dist) и [расстояние городских кварталов](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%B3%D0%BE%D1%80%D0%BE%D0%B4%D1%81%D0%BA%D0%B8%D1%85_%D0%BA%D0%B2%D0%B0%D1%80%D1%82%D0%B0%D0%BB%D0%BE%D0%B2) (taxicab_dist). В финальном решении для определения сходства используется евклидово расстояние, но его можно заменить на иное и посмотреть, как изменится результат классификации. Существуют и другие функции расстояния, их выбор зависит от конкретной задачи.

При выборе метрики стоит стремиться к максимизации суммы расстояний между объектами разных классов и минимизации расстояний между объектами одного класса. Таким образом разные классы будут лежать далеко друг от друга, а схожие - рядом.

Таким образом к одному классу будут относиться, к примеру, крепкие вина с большой кислотностью, а слабые с менее выраженным вкусом - к другому.
### Задание

Реализуйте функцию, предсказывающую метки класса по известным примерам. Функция `knn` должна принимать:
- обучающую выборку `X_train`, `y_train`
- выборку, которую нужно классифицировать, `X_test`
- количество соседей `k`
- функцию расстояния `dist`

Выходом функции является вектор `y_test`, в котором для каждого
элемента `X_test` хранится соответствующий ему класс.

```python
def knn(X_train, y_train, X_test, k, dist):
    return #class for each x in the X_test
```

В данном задании могут быть полезны такие функции **NumPy**, как:
- [numpy.argpartition](https://docs.scipy.org/doc/numpy/reference/generated/numpy.argpartition.html), возвращающая все аргументы элементов массива меньшие заданного элемента в массиве перед ним, а большие - после него. Данная функция поможет вычленить ближайших соседей в массиве, отсортированном по расстоянию.
- [numpy.bincount](https://docs.scipy.org/doc/numpy/reference/generated/numpy.bincount.html) возвращает количество каждого из элементов в массиве неотрицательных чисел. Данная функция поможет вычислить количество тех или иных классов среди соседей.
- [numpy.argmax](https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.html) возвращает индексы наибольших значений. К примеру, наиболее часто встречающихся меток того или иного класса.
